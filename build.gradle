subprojects {
    apply plugin: 'java-library'
    apply plugin: 'maven-publish'

    group 'io.ketill'
    version '0.0.1-SNAPSHOT'

    sourceCompatibility = 1.8
    targetCompatibility = 1.8

	publishing {
		publications {
            maven(MavenPublication) {
                from components.java
            }
        }
	}

    repositories {
        mavenLocal()
        mavenCentral()
    }

    test {
        useJUnitPlatform()
    }

    dependencies {
        compileOnly 'org.jetbrains:annotations:22.0.0'

        api 'org.joml:joml:1.10.2'

        testCompileOnly 'org.jetbrains:annotations:22.0.0'
        testImplementation 'org.junit.jupiter:junit-jupiter-api:5.8.2'
        testImplementation 'org.junit.jupiter:junit-jupiter-engine:5.8.2'
        testImplementation 'org.mockito:mockito-inline:4.3.1'
        testImplementation 'org.mockito:mockito-junit-jupiter:4.3.1'
        testImplementation 'nl.jqno.equalsverifier:equalsverifier:3.10'

        if(project.name != "testing") {
            testImplementation project(':testing')
        }
    }

    java {
        withSourcesJar()
        withJavadocJar()
    }

    archivesBaseName = "${rootProject.name}-${project.name}"

    /*
     * Some modules in this project are blank modules. They are
     * simply folders which contain for real modules. By default,
     * Gradle will output JARs for them, even though they have
     * no source code. The closures below disable this behavior.
     */
    def blankModules = ["adapters", "devices"]
    if(blankModules.contains(project.name)) {
        tasks.jar.enabled = false
        tasks.sourcesJar.enabled = false
        tasks.javadocJar.enabled = false
		
		tasks.publishMavenPublicationToMavenLocal.enabled = false
    }

}
